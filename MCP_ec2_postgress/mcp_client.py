from anthropic import Anthropic
import subprocess
import time
import psycopg2
import re

class MCPClient:
    """
    Client for the Model Context Protocol (MCP) with PostgreSQL.
    Allows making natural language queries to a PostgreSQL database.
    """

    def __init__(self, api_key, pg_connection, model="claude-3-haiku-20240307", max_tokens=1000):
        """
        Initializes the MCP client.

        Args:
            api_key (str): Anthropic API key
            pg_connection (str): PostgreSQL connection string
            model (str): Claude model to use
            max_tokens (int): Maximum number of tokens in the response
        """
        self.api_key = api_key
        self.pg_connection = pg_connection
        self.model = model
        self.max_tokens = max_tokens
        self.anthropic = Anthropic(api_key=api_key)

        # Default system prompt
        self.system_prompt = """
        You are an assistant specialized in PostgreSQL database queries.
        You have access to a database with the following tables:

        1. departments (id, name, location)
        2. employees (id, first_name, last_name, email, hire_date, salary, department_id)
           - department_id is a foreign key that relates to departments(id)
        3. projects (id, name, start_date, end_date, budget, status)
        4. assignments (employee_id, project_id, assignment_date, role)
           - employee_id is a foreign key that relates to employees(id)
           - project_id is a foreign key that relates to projects(id)

        Provide the exact SQL query needed to answer the question.
        """

    def set_system_prompt(self, prompt):
        """
        Sets a custom system prompt.

        Args:
            prompt (str): New system prompt
        """
        self.system_prompt = prompt

    def execute_sql_query(self, query):
        """
        Executes an SQL query directly in PostgreSQL and returns the results.

        Args:
            query (str): SQL query to execute

        Returns:
            tuple: (column_names, results) or (None, error_message)
        """
        try:
            # Connect to PostgreSQL
            conn = psycopg2.connect(self.pg_connection)
            cursor = conn.cursor()

            
            cursor.execute(query)

         
            results = cursor.fetchall()

        
            column_names = [desc[0] for desc in cursor.description] if cursor.description else []

            # Close connection
            cursor.close()
            conn.close()

            return column_names, results
        except Exception as e:
            return None, f"Error executing the query: {str(e)}"

    def extract_sql_query(self, text):
        """
        Extracts the SQL query from the text generated by Claude.

        Args:
            text (str): Response text from Claude

        Returns:
            str or None: Extracted SQL query or None if not found
        """
        # Look for common SQL query patterns
        sql_patterns = [
            r"```sql\s*([\s\S]*?)\s*```",  # SQL inside markdown code blocks
            r"SELECT[\s\S]*?(?:;|$)",      # SELECT queries
            r"WITH[\s\S]*?SELECT[\s\S]*?(?:;|$)"  # CTE queries (WITH)
        ]

        for pattern in sql_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            if matches:
                # Take the longest query found
                return max(matches, key=len).strip()

        return None

    def query(self, question, callback=None):
        """
        Processes a natural language query and returns the results.

        Args:
            question (str): Natural language question
            callback (function, optional): Function to report progress

        Returns:
            dict: Process results
        """
        # Start MCP PostgreSQL server
        mcp_process = subprocess.Popen(
            ["npx", "@modelcontextprotocol/server-postgres", self.pg_connection],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        try:
            # Give the server time to start
            time.sleep(2)

            # Notify progress if there's a callback
            if callback:
                callback("Querying Claude...")

            # Query Claude to generate the SQL query
            message = self.anthropic.messages.create(
                model=self.model,
                max_tokens=self.max_tokens,
                system=self.system_prompt,
                messages=[{"role": "user", "content": question}]
            )

            # Notify progress
            if callback:
                callback("Extracting SQL query...")

            # Extract text from the response content
            content_text = ""
            if hasattr(message.content, 'text'):
                content_text = message.content.text
            elif isinstance(message.content, list):
                # If it's a list of blocks, concatenate the text from each one
                for block in message.content:
                    if hasattr(block, 'text'):
                        content_text += block.text
            else:
                # If it's a direct string
                content_text = str(message.content)

            # Extract the SQL query from the text
            sql_query = self.extract_sql_query(content_text)

            if sql_query:
                # Notify progress
                if callback:
                    callback("Executing query in PostgreSQL...")

                # Execute the SQL query directly in PostgreSQL
                column_names, results = self.execute_sql_query(sql_query)

                return {
                    "claude_response": content_text,
                    "sql_query": sql_query,
                    "column_names": column_names,
                    "results": results,
                    "success": True
                }
            else:
                return {
                    "claude_response": content_text,
                    "sql_query": None,
                    "error": "Could not extract a valid SQL query from the response.",
                    "success": False
                }

        except Exception as e:
            return {
                "error": f"Error: {str(e)}",
                "success": False
            }

        finally:
            # Stop the MCP server
            if mcp_process.poll() is None:
                mcp_process.terminate()
                mcp_process.wait(timeout=5)


if __name__ == "__main__":
    import sys
    import os

    # Get API key and connection from environment variables or default values
    api_key = os.environ.get("ANTHROPIC_API_KEY", "your_api_key_here")
    pg_connection = os.environ.get("PG_CONNECTION", "postgresql://mcp_user:123456@localhost:5432/mcp_db")

    # Create client
    client = MCPClient(api_key, pg_connection)

    # Process arguments or enter interactive mode
    if len(sys.argv) > 1:
        query = " ".join(sys.argv[1:])
        print(f"Question: {query}")

        # Simple callback to show progress
        def print_status(status):
            print(f"Status: {status}")

        # Execute query
        result = client.query(query, callback=print_status)

        if result.get("success", False):
            print("\nGenerated SQL query:")
            print(result["sql_query"])
            print("\nResults:")

            if result["column_names"]:
                # Show headers
                print(" | ".join(result["column_names"]))
                print("-" * (sum(len(name) for name in result["column_names"]) + 3 * (len(result["column_names"]) - 1)))

                # Show rows
                for row in result["results"]:
                    print(" | ".join(str(value) for value in row))

                print(f"\nTotal results: {len(result['results'])}")
            else:
                print(result.get("results", "No results."))
        else:
            print(f"\nError: {result.get('error', 'Unknown error')}")
    else:
        print("MCP Client for PostgreSQL")
        print("Type a question or 'exit' to quit")

        while True:
            query = input("\n> ")
            if query.lower() in ['exit', 'quit']:
                break

            # Execute query
            result = client.query(query)

            if result.get("success", False):
                print("\nGenerated SQL query:")
                print(result["sql_query"])
                print("\nResults:")

                if result["column_names"]:
                    # Show headers
                    print(" | ".join(result["column_names"]))
                    print("-" * (sum(len(name) for name in result["column_names"]) + 3 * (len(result["column_names"]) - 1)))

                    # Show rows
                    for row in result["results"]:
                        print(" | ".join(str(value) for value in row))

                    print(f"\nTotal results: {len(result['results'])}")
                else:
                    print(result.get("results", "No results."))
            else:
                print(f"\nError: {result.get('error', 'Unknown error')}")
